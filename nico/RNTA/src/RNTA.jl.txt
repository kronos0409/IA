# RNTA.jl - Red Neuronal Tensorial Adaptativa
# Archivo principal que exporta todas las funcionalidades

module RNTA

# Importaciones de paquetes estándar de Julia
using LinearAlgebra
using Statistics
using Random
using Flux
using CUDA
using NNlib
using ProgressMeter
using Distributions
using Zygote
using ChainRules
using DataStructures

# Configuración global
const VERSION = v"0.1.0"
const DEBUG_MODE = false
const DEFAULT_DTYPE = Float32

# Incluir los módulos principales del sistema
include("core/TensorNeuron.jl")
include("core/SpatialField.jl")
include("core/BrainSpace.jl")
include("core/Connections.jl")

include("operations/TensorTransformations.jl")
include("operations/VolumetricActivations.jl")
include("operations/SpatialAttention.jl")
include("operations/PropagationDynamics.jl")

include("adaptation/DynamicExpansion.jl")
include("adaptation/Specialization.jl")
include("adaptation/SelfPruning.jl")
include("adaptation/PlasticityRules.jl")

include("training/MultidimensionalLoss.jl")
include("training/SpatialOptimizers.jl")
include("training/GradientPropagation.jl")
include("training/ModelCloning.jl")

include("nlp/TensorialTokenizer.jl")
include("nlp/SemanticSpace.jl")
include("nlp/ContextualMapping.jl")
include("nlp/LanguageGeneration.jl")

include("architecture/CorticalLayers.jl")
include("architecture/HippocampalMemory.jl")
include("architecture/PrefrontalSystem.jl")
include("architecture/AttentionalSystem.jl")

include("inference/InternalDialogue.jl")
include("inference/ReasoningPathways.jl")
include("inference/UncertaintyEstimation.jl")
include("inference/MultimodalIntegration.jl")

include("acceleration/CUDATensors.jl")
include("acceleration/TensorParallelism.jl")
include("acceleration/MemoryOptimization.jl")
include("acceleration/HardwareAdaptation.jl")

include("utils/TensorIO.jl")
include("utils/Serialization.jl")
include("utils/PerformanceMetrics.jl")
include("utils/ConfigurationSystem.jl")

# Configuración inicial del sistema
function __init__()
    # Detectar disponibilidad de GPU
    if CUDA.functional()
        @info "CUDA detectado. Usando aceleración GPU por defecto."
        use_cuda_tensors()
    else
        @info "CUDA no detectado. Usando implementación CPU."
    end
    
    # Inicializar generador de números aleatorios
    Random.seed!(time_ns())
    
    # Inicializar sistema de configuración
    init_configuration()
    
    # Inicializar sistema de métricas
    init_performance_metrics()
    
    @info "RNTA inicializado. Versión: $VERSION"
end

# Exportar tipos y funciones principales
export TensorNeuron, SpatialField, BrainSpace, TensorConnection
export create_brain, process, train!, expand_space, visualize_activity
export TensorialTokenizer, process_text, generate_text
export MultidimensionalLoss, SpatialOptimizer, internal_dialogue
export CorticalLayer, PrefrontalSystem, AttentionalSystem

# Funciones de conveniencia para el usuario final
"""
    create_brain(dim_x, dim_y, dim_z; config=default_config())

Crea un nuevo espacio cerebral 3D con las dimensiones especificadas.
"""
function create_brain(dim_x::Int, dim_y::Int, dim_z::Int; config=default_config())
    return BrainSpace(dim_x, dim_y, dim_z, config=config)
end

"""
    process(brain, input_data)

Procesa los datos de entrada a través del espacio cerebral.
"""
function process(brain::BrainSpace, input_data)
    # Convertir entrada a representación tensorial
    tensor_input = to_tensor_representation(input_data, brain)
    
    # Procesar a través del espacio cerebral
    return forward_propagation(brain, tensor_input)
end

"""
    train!(brain, input_data, target_data; 
           loss_function=default_loss(), optimizer=default_optimizer(), 
           epochs=1, batch_size=1)

Entrena el espacio cerebral con los datos proporcionados.
"""
function train!(brain::BrainSpace, input_data, target_data; 
                loss_function=default_loss(), 
                optimizer=default_optimizer(),
                epochs=1, 
                batch_size=1)
    
    progress = Progress(epochs, desc="Entrenando...")
    
    for epoch in 1:epochs
        batch_indices = batch_data(length(input_data), batch_size)
        
        epoch_loss = 0.0
        
        for batch_idx in batch_indices
            # Obtener batch actual
            batch_input = input_data[batch_idx]
            batch_target = target_data[batch_idx]
            
            # Procesar batch
            batch_loss = process_training_batch!(
                brain, 
                batch_input, 
                batch_target, 
                loss_function, 
                optimizer
            )
            
            epoch_loss += batch_loss
        end
        
        # Registrar métricas
        log_training_metrics(brain, epoch, epoch_loss / length(batch_indices))
        
        # Actualizar barra de progreso
        next!(progress, showvalues=[(:epoch, epoch), (:loss, epoch_loss / length(batch_indices))])
        
        # Comprobar si es necesario expandir el espacio
        if should_expand_space(brain)
            expand_space!(brain)
        end
        
        # Ejecutar auto-optimización periódica
        if epoch % brain.config.pruning_frequency == 0
            self_prune!(brain)
        end
    end
    
    return brain
end

end # module RNTA